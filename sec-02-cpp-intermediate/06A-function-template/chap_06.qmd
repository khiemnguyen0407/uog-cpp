---
title: "Function template"
# subtitle: "Control Flow"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: simple   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        mouse-wheel: true
        highlight-style: github
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        chalkboard: true
        css: simple.css
---

# Introduction to template

## We saw the use template in the lab assignments

We saw the use of template already: 

- `std::vector<double>`
- `std::vector<int>`

Other examples of template classes:

- `std::list<std::string>`
- `std::map<str::string, map>`

Other examples of template functions:

- `std::max(1, 2)   // input arguments: int and int; compiler understands`
- `std::max<double>(10, 42.24) // to treat both as doubles`

ðŸ˜Œ I hope it's pretty natural to understand what these data types mean.

## Rationale for template

- Let us consider a function to find the maximum of two numbers:
```{.cpp}
int max(int x, int y)
{ 
    return (x < y) ? y : x; // Note: we use < instead of > because std::max uses <
}
```
- So what happens later when you want to find the max of two double values? The solution is to create a new overloaded version of `max`
```{.cpp}
double max(double x, double y)
{
    return (x < y) ? y: x;
}
```

:::{.fragment}
Now, the problem arises here. What about many different data types: `int`, `double`, `long`, `long double` and so on?
:::
:::{.fragment}
Fortunately, C++ supports another feature that was designed specifically to solve this kind of problem: C++ templates
:::

## Intro to C++ template

Before explaining the template, let us consider the following code snippet:

```{.cpp}
T max(T x, T y) // won't compile because we haven't defined T
{
    return (x < y) ? y : x;
}
```
- We wish that `T` can be any data type so that the comparison `x < y` makes sense.
- How nice it is if this piece of code can compile and give us what we expected.

## Intro to C++ template

**Template** 

::: {.incremental}
- To simplify the process of creating functions/classes that are able to work with different data types.
- To create a _single template_ instead of a bunch of mostly-identical functions/classes.
- To Provide a _placeholder type_ representing some type that is not known at the time the template is defined.
- To generate as many overloaded functions/classes as needed
:::

In the rest of this chapter, we explore how to create **function templates**.

# Function templates

## Terminologies: About function templates

::: {.incremental}
- A **function template** is a function-like definition that is used to generate one or more overloaded functions, each with a different set of actual types.
- The initial function template that is used to generate other functions is called the **primary template**.
- The functions generated from the primary template are called **instantiated functions**.
- When we create a _primary function template_, we use placeholder types, technically called **type template parameters**, informally called **template types**.
:::

## Creating a function template

Recall out `max()` function
```{.cpp}
int max(int x, int y)
{
    return (x < y) ? y : x;
}
```

Our wishful piece code
```{.cpp}
T max(T x, T y)     // won't compile because we haven't defined T
{
    return (x < y) ? y : x;
}
```

We need

- to tell the compiler that this is a template, and that `T` is a _type template parameter_. 
- to use a **template parameter declaration**.

## Use template parameter declaration

Each function template/class template needs its own **template parameter declaration**.

```{.cpp}
// this is the template parameter declaration 
// defining T as a type template parameter
template <typename T> 
T max(T x, T y)     // this is the function template definition for max<T>
{
    return (x < y) ? y : x;
}
```

**Summary**  

- Start with the keyword `template`.
- Use keyword `typename` (preferred) or `class`, followed by the name of the type template parameter (e.g. `T`).


# Naming convention of template parameters

## Naming template parameters

**Naming convention**

- Use a single capital letter (starting with T) when the template parameter is used in a trivial or obvious way.
- No need to give T a complex name, because itâ€™s obviously just a placeholder type.

```{.cpp #lst-template-function-conventional-naming lst-cap="Use template naming convention"}
template <typename T>
T max(T x, T y)
{
    return (x < y) ? y : x;
}
```

```{.cpp #lst-template-function-nonconventional-naming lst-cap="Use whatever name you like"}
template <typename Bullshit>
Bullshit max(Bullshit x, Bullshit y)
{
    return (x < y) ? y : x;
}
```

## Naming template parameters

For non-obvious usage o specific requirements, there are two common naming conventions:

- Starting with a capital letter (e.g. `Allocator`). _The standard library uses this naming convention_.
- Prefixed with a `T`, then starting with a capital letter (e.g. `TAllocator`).

> **Best practice to use**
>
> Use a single capital letter starting with `T` (e.g., `T`, `U`, `V`, etc.) to name type template parameters that used in trivial or obvious ways.


# Function template instantiation

We learn how function templates are used.

## Using a function template

**About function template**

- Function templates are not actually functions. 
- Their code is not compiled or executed directly.
- Function templates are used to generate functions that are compiled and executed.

**Use function template**

- Make a function call with the syntax
  
    ```{.cpp}
    // actual_type is some actual type, like int or double
    max<actual_type>(arg1, arg2); 
    ```
- The type in angled brackets is called **template argument**.

## Using a function template

::: {#lst-use-template-function lst-cap="An example of using template function &ndash; Filename: `use_template_function.cpp`"}
```{.cpp}
{{< include ./cpp/use_template_function.cpp >}}
```
:::
- When the compiler encounters `max<int>(1, 2)`, it determines that a function definition for `max<int>(int, int)` does not already exist.
- The compiler will implicitly use `max<T>` function template to create one.

## Function template instantiation

### Terminologies

::: {.incremental}
- The process of creating functions (with specific types) from function templates (with template types) is called **function template instantiation**.
- When a function is instantiated due to a function call, itâ€™s called **implicit instantiation**.
- A function that is instantiated from a template is technically called a **specialization**, but in common language is often called a **function instance**.
- The template from which a **specialization** is produced is called a **primary template**.
- _Function instances are normal functions in all regards._
:::

::: {.fragment}
> **Remember**
>
> Function template is not a function. It helps to create functions.
:::

## Function template instantiation

&#10149; **Process for instantiating a function**  

The compiler essentially clones the primary template and replaces the template type (`T`) with the actual type we have specified.

- When we call `max<int>(1, 2)`, the function specialization that gets instantiated looks like

```{.cpp}
template<> // ignore this for now
int max<int>(int x, int y) // the generated function max<int>(int, int)
{
    return (x < y) ? y : x;
}
``` 

## Function template instantiation: More
&#10149; What the compiler actually compiles after all the instantiation are done:

```{.cpp}
{{< include ./cpp/instantiation_look_breakdown.cpp >}}
```
&#10149; Let us compile it and run to see.

## Function template instantiation

- A function template is only instantiated the first time a function call is made.
- Further calls to the function are routed to the already instantiated function.
-  if no function call is made to a function template, the function template won't be instantiated.

```{.cpp}
{{< include ./cpp/instantiation_look_more.cpp >}}
```

## Function template instantiation: More
Let us breakdown the above `cpp` example

```{.cpp}
{{< include ./cpp/instantiation_look_more_breakdown.cpp >}}
```

# Template argument deduction

## Template argument deduction: Explanation

&#10149; In most cases, the actual types we want to use for instantiation will match the type of our function parameters.
```{.cpp}
std::cout << max<int>(1, 2) << '\n'; // specifying we want to call max<int>
```

&#10149; Instead of making a function call like
```{.cpp}
std::cout << max<int>(1, 2) << '\n';
```
we can do one of these:

```{.cpp}
std::cout << max<>(1, 2) << '\n';
```
or 
```{.cpp}
std::cout << max(1, 2) << '\n';
```

&#10149; Further explanation on this soon!

## Template argument deduction: Explanation

**Quick summary**

- In cases where the type of the arguments match the actual type we want, we do not need to specify the actual type.
- instead, we can use template argument deduction to have the compiler deduce the actual type that should be used from the argument types in the function call.

## Template argument deduction: Explanation

Let us consider again:

- `max<>(1, 2)`
- `max(1, 2)`

Difference between two cases: How the compiler resolves the function call from a set of overloaded functions.

- In the top case (empty angled brackets), the compiler will only consider `max<int>` _template function overloads_.
- In the bottom case (no angled brackets), the compiler will consider both `max<int>` _template function overloads_ **and** `max` _non-template function overloads_.
- When the bottom case results in both a template function and a non-template function that are equally viable, [the non-template function will be preferred]{style="color:red"}.

> **Key insight**
> 
> The normal function call syntax will prefer a non-template function over an equally viable function instantiated from a template.


## Template argument deduction: Explanation

```{.cpp}
{{< include ./cpp/template_argument_deduction_more.cpp >}}
```
- Note hwo the syntax in the bottom case looks identical to a normal function call.
- _In most cases_, this normal function call syntax is the one we use to call functions instantiated from a function template.

## Favor normal function call over function template call

**Best practice**

Favor the normal function call syntax when making calls to a function instantiated from a function template (unless you need the function template version to be preferred over a matching non-template function).

## Favor normal function call over function template call

:::{#lst-favor-normal-function lst-cap="Favor normal function call over function template call. Filename=`favor_normal_func_over_func_template_call.cpp`"}
```{.cpp}
{{< include ./cpp/favor_normal_func_over_func_template_call.cpp >}}
```
:::

&#10149; Let us compile and see the output.

# Further on function templates

## Function templates with non-template parameters

*It's not a surprising*: We can create [function templates that have both template parameters and non-template parameters]{style="color:blue"}

:::{#lst-func-template-with-non-template-para lst-cap="Function template with non-template parameters Filename=`func_template_with_non_template_parameters.cpp`"}
```{.cpp}
{{< include ./cpp/func_template_with_non_template_parameters.cpp >}}
```
:::

## Instantiated functions may not always compile

&#10149; Look at this example

:::{#lst-instantiated-not-compile lst-cap="An instantiated function that does not compile. Filename=`instantiated_func_not_compile.cpp`"}
```{.cpp}
{{< include ./cpp/instantiated_func_not_compile.cpp >}}
```
:::

## Instantiated functions may not always make sense semantically

&#10149; Look at this example

:::{#lst-not-make-sense-semantically lst-cap="Instantiated function that does not make sense sematically Filename=`not_make_sense_semantically.cpp`"}
```{.cpp}
{{< include ./cpp/not_make_sense_semantically.cpp >}}
```
:::

## Function templates and default arguments for non-template parameters

